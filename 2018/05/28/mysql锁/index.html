<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>mysql insert Gap死锁 | 小菜园</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Gap 锁死锁问题

线上时不时会报mysql-insert-deadlock,经排查发现是由于gap锁和Insert Intention锁多线程并发时互斥而造成的死锁。原代码逻辑：先删除（通过索引删除），再插入gap锁：
例子分析执行 delete from order where customer_id = 3。这里在order表里面没有customer_id=3 的记录。但是又由于cust">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql insert Gap死锁">
<meta property="og:url" content="http://bravemind.github.io/2018/05/28/mysql锁/index.html">
<meta property="og:site_name" content="小菜园">
<meta property="og:description" content="Gap 锁死锁问题

线上时不时会报mysql-insert-deadlock,经排查发现是由于gap锁和Insert Intention锁多线程并发时互斥而造成的死锁。原代码逻辑：先删除（通过索引删除），再插入gap锁：
例子分析执行 delete from order where customer_id = 3。这里在order表里面没有customer_id=3 的记录。但是又由于cust">
<meta property="og:updated_time" content="2018-05-31T09:37:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mysql insert Gap死锁">
<meta name="twitter:description" content="Gap 锁死锁问题

线上时不时会报mysql-insert-deadlock,经排查发现是由于gap锁和Insert Intention锁多线程并发时互斥而造成的死锁。原代码逻辑：先删除（通过索引删除），再插入gap锁：
例子分析执行 delete from order where customer_id = 3。这里在order表里面没有customer_id=3 的记录。但是又由于cust">
  
  
    <link rel="icon" href="/blog/favicon.png">
  
  <link rel="stylesheet" href="/blog/css/normalize.css">
  <link rel="stylesheet" href="/blog/css/grid.css">

  <link rel="stylesheet" href="/blog/css/style.css">
  <link rel="stylesheet" href="/blog/css/font-awesome.min.css">



</head>
<div class="left_header">
    <a class="header_avater" href="/blog"></a>
    <div class="tag_s" id="showTag">
        <i class="fa fa-tag" href="../blog"></i>
            <div id="tags_clod" class="pop">
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/JavaScript/">JavaScript</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Mysql/">Mysql</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/java基础/">java基础</a><span class="tag-list-count">35</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/linux/">linux</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/技术求索/">技术求索</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/设计模式/">设计模式</a><span class="tag-list-count">27</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/译文/">译文</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/读书笔记/">读书笔记</a><span class="tag-list-count">1</span></li></ul>
            </div>
    </div>
    <a href="/blog/archives/"><i class="fa fa-list-ul"></i></a>
    <a href="https://github.com/braveMind" class="git" target="_blank"><i class="fa fa-github"></i></a>


    <a href="/blog/tags/think"><i class="fa fa-pencil-square-o"></i></a>
    <a href="/blog/2016/05/21/友情链接/"><i class="fa fa-link" aria-hidden="true"></i></a>

</div>
<div class="left_content">
    <section><article id="post-mysql锁" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      mysql insert Gap死锁
    </h1>
  

        <a href="/blog/2018/05/28/mysql锁/" class="article-data-title">

  <time  datetime="2018-05-28T08:33:13.000Z" itemprop="datePublished">2018-05-28</time>
</a>

      </header>
    
   <!-- <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Gap 锁死锁问题</p>
</blockquote>
<p>线上时不时会报mysql-insert-deadlock,经排查发现是由于gap锁和Insert Intention锁多线程并发时互斥而造成的死锁。<br>原代码逻辑：<br>先删除（通过索引删除），再插入gap锁：</p>
<h2 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h2><p>执行 delete from <code>order</code> where customer_id = 3。这里在order表里面没有customer_id=3 的记录。但是又由于customer_id存在一个索引，mysql根据索引进行搜索，索引的key是(1,2,6)，3不在这些key里面而是位于(2,6)之间的gap（间隙）中。Mysql对于(2,6)这个间隙加的锁就叫做Gap锁。</p>
<h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><p>原有逻辑分析(举例)：</p>
<p>A   ：T1  stagedPoiRoomBedInfoDAO.deleteByRoomId(3);</p>
<p>B   ：T2  stagedPoiRoomBedInfoDAO.deleteByRoomId(4);</p>
<p>C   ：T1  stagedPoiRoomBedInfoDAO.insert(stagedPoiRoomBedInfoDO1);</p>
<p>D   ：T2  stagedPoiRoomBedInfoDAO.insert(stagedPoiRoomBedInfoDO2);</p>
<p> 执行A语句完毕，T1持有了Gap(2,6)的X锁；（假设3，4在索引段2，6之间）</p>
<p> 执行B语句，T2 申请Gap(2,6)的X锁，该申请被授权，所以T2 持有了Gap(2,6)的X锁。</p>
<p> 执行C语句，T1 申请Insert Intention (2,6)的X锁，根据之前讲的互斥关系，由于T2持有Gap(2,6)的X锁，该申请被block。</p>
<p> 执行D语句，T2 申请 Insert Intention(2,6)的X锁，根据之前讲的互斥关系，由于T1持有Gap(2,6)的X锁，该申请被block。</p>
<p> 这里一个死锁很明显的出现，T1与T2都持有一个锁，同时都在等对方释放一个锁。到这里，整个死锁的原因分析清楚了。  </p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>只要消除了Gap锁，这个死锁就解决了。</p>
<p>在delete的时候，不让事务获取到Gap锁。比如，在执行delete from   <code>order</code>  where customer_id = 3 ;之前， 我们可以先用主键查询看数据是否存在，存在再用主键删除，即可解决上述的死锁问题。</p>
<p><strong>ps：两个锁的互斥关系如下</strong><br>存在Insert Intention 锁时，申请Gap锁是允许的；但是存在Gap锁时，申请Insert Intention锁时是被阻止的。<strong>Gap锁是共享锁。</strong></p>
<h2 id="什么时候会取得-gap-lock-或nextKey锁"><a href="#什么时候会取得-gap-lock-或nextKey锁" class="headerlink" title="什么时候会取得 gap lock 或nextKey锁"></a>什么时候会取得 gap lock 或nextKey锁</h2><p>这和隔离级别有关,只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。</p>
<p>For locking reads (<strong>SELECT with FOR UPDATE or LOCK IN SHARE MODE</strong>), <strong>UPDATE statements, and DELETE statements</strong>, InnoDB locks only index records, not the gaps before them, and thus permits the free insertion of new records next to locked records. Gap locking is only used for foreign-key constraint checking and duplicate-key checking.</p>
<p>Because gap locking is disabled, phantom problems may occur, as other sessions can insert new rows into the gaps. For information about phantoms, see Section 14.5.4, “Phantom Rows”.</p>
<p>Only row-based binary logging is supported with the READ COMMITTED isolation level. If you use READ COMMITTED with binlog_format=MIXED, the server automatically uses row-based logging.</p>
<p>Using READ COMMITTED has additional effects:</p>
<p>For UPDATE or DELETE statements, InnoDB holds locks only for rows that it updates or deletes. Record locks for nonmatching rows are released after MySQL has evaluated the WHERE condition. This greatly reduces the probability of deadlocks, but they can still happen.</p>
<p>For UPDATE statements, if a row is already locked, InnoDB performs a “semi-consistent” read, returning the latest committed version to MySQL so that MySQL can determine whether the row matches the WHERE condition of the UPDATE. If the row matches (must be updated), MySQL reads the row again and this time InnoDB either locks it or waits for a lock on it.</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html" target="_blank" rel="external">参考</a></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>GAP锁，锁的是区间，并不是最末端的几行，最大的记录到 +∞区间都被锁了，这个区间内的所有插入都会失败</p>
<p>举个例子，表中最大id是10，错误id是10000，这样锁住的范围是10 ~ 正无穷大。这样插入大于10的id都会锁等待。</p>

      


    </div>-->
    <div class="article-entry" itemprop="articleBody">
      
      
      <div id="toc" class="article-toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#例子分析"><span class="toc-number">1.</span> <span class="toc-text">例子分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#场景举例"><span class="toc-number">2.</span> <span class="toc-text">场景举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决思路"><span class="toc-number">3.</span> <span class="toc-text">解决思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么时候会取得-gap-lock-或nextKey锁"><span class="toc-number">4.</span> <span class="toc-text">什么时候会取得 gap lock 或nextKey锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#思考"><span class="toc-number">5.</span> <span class="toc-text">思考</span></a></li></ol>
        <hr/>
      </div>
      
      <blockquote>
<p>Gap 锁死锁问题</p>
</blockquote>
<p>线上时不时会报mysql-insert-deadlock,经排查发现是由于gap锁和Insert Intention锁多线程并发时互斥而造成的死锁。<br>原代码逻辑：<br>先删除（通过索引删除），再插入gap锁：</p>
<h2 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h2><p>执行 delete from <code>order</code> where customer_id = 3。这里在order表里面没有customer_id=3 的记录。但是又由于customer_id存在一个索引，mysql根据索引进行搜索，索引的key是(1,2,6)，3不在这些key里面而是位于(2,6)之间的gap（间隙）中。Mysql对于(2,6)这个间隙加的锁就叫做Gap锁。</p>
<h2 id="场景举例"><a href="#场景举例" class="headerlink" title="场景举例"></a>场景举例</h2><p>原有逻辑分析(举例)：</p>
<p>A   ：T1  stagedPoiRoomBedInfoDAO.deleteByRoomId(3);</p>
<p>B   ：T2  stagedPoiRoomBedInfoDAO.deleteByRoomId(4);</p>
<p>C   ：T1  stagedPoiRoomBedInfoDAO.insert(stagedPoiRoomBedInfoDO1);</p>
<p>D   ：T2  stagedPoiRoomBedInfoDAO.insert(stagedPoiRoomBedInfoDO2);</p>
<p> 执行A语句完毕，T1持有了Gap(2,6)的X锁；（假设3，4在索引段2，6之间）</p>
<p> 执行B语句，T2 申请Gap(2,6)的X锁，该申请被授权，所以T2 持有了Gap(2,6)的X锁。</p>
<p> 执行C语句，T1 申请Insert Intention (2,6)的X锁，根据之前讲的互斥关系，由于T2持有Gap(2,6)的X锁，该申请被block。</p>
<p> 执行D语句，T2 申请 Insert Intention(2,6)的X锁，根据之前讲的互斥关系，由于T1持有Gap(2,6)的X锁，该申请被block。</p>
<p> 这里一个死锁很明显的出现，T1与T2都持有一个锁，同时都在等对方释放一个锁。到这里，整个死锁的原因分析清楚了。  </p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>只要消除了Gap锁，这个死锁就解决了。</p>
<p>在delete的时候，不让事务获取到Gap锁。比如，在执行delete from   <code>order</code>  where customer_id = 3 ;之前， 我们可以先用主键查询看数据是否存在，存在再用主键删除，即可解决上述的死锁问题。</p>
<p><strong>ps：两个锁的互斥关系如下</strong><br>存在Insert Intention 锁时，申请Gap锁是允许的；但是存在Gap锁时，申请Insert Intention锁时是被阻止的。<strong>Gap锁是共享锁。</strong></p>
<h2 id="什么时候会取得-gap-lock-或nextKey锁"><a href="#什么时候会取得-gap-lock-或nextKey锁" class="headerlink" title="什么时候会取得 gap lock 或nextKey锁"></a>什么时候会取得 gap lock 或nextKey锁</h2><p>这和隔离级别有关,只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。</p>
<p>For locking reads (<strong>SELECT with FOR UPDATE or LOCK IN SHARE MODE</strong>), <strong>UPDATE statements, and DELETE statements</strong>, InnoDB locks only index records, not the gaps before them, and thus permits the free insertion of new records next to locked records. Gap locking is only used for foreign-key constraint checking and duplicate-key checking.</p>
<p>Because gap locking is disabled, phantom problems may occur, as other sessions can insert new rows into the gaps. For information about phantoms, see Section 14.5.4, “Phantom Rows”.</p>
<p>Only row-based binary logging is supported with the READ COMMITTED isolation level. If you use READ COMMITTED with binlog_format=MIXED, the server automatically uses row-based logging.</p>
<p>Using READ COMMITTED has additional effects:</p>
<p>For UPDATE or DELETE statements, InnoDB holds locks only for rows that it updates or deletes. Record locks for nonmatching rows are released after MySQL has evaluated the WHERE condition. This greatly reduces the probability of deadlocks, but they can still happen.</p>
<p>For UPDATE statements, if a row is already locked, InnoDB performs a “semi-consistent” read, returning the latest committed version to MySQL so that MySQL can determine whether the row matches the WHERE condition of the UPDATE. If the row matches (must be updated), MySQL reads the row again and this time InnoDB either locks it or waits for a lock on it.</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html" target="_blank" rel="external">参考</a></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>GAP锁，锁的是区间，并不是最末端的几行，最大的记录到 +∞区间都被锁了，这个区间内的所有插入都会失败</p>
<p>举个例子，表中最大id是10，错误id是10000，这样锁住的范围是10 ~ 正无穷大。这样插入大于10的id都会锁等待。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://bravemind.github.io/blog/2018/05/28/mysql锁/" data-id="cjjik5ouw0035yhoj1q62k724" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Mysql/">Mysql</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2018/07/12/maven插件编写/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          maven插件编写
        
      </div>
    </a>
  
  
    <a href="/blog/2017/12/05/反射调用被Spring代理的类/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">反射调用被Spring代理的类</div>
    </a>
  
</nav>

  
</article>



</section>
</div>


   

   <script src="/blog/js/jQuery.js"></script>
   <script src="/blog/js/script.js"></script>



